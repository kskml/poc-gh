def clean_confluence_html(html_content):
    """
    Replaces complex macros with clean text.
    FIX: Modified General Cleanup to ignore macros containing content (headers, paragraphs).
    This prevents consuming text headers wrapped in panel/container macros.
    """
    print("   Cleaning macros (Preserving content)...")
    
    # 1. Draw.io
    # Using anti-greedy lookahead
    pattern_drawio = re.compile(
        r'<ac:structured-macro ac:name=".*?drawio.*?"[^>]*>(?!.*<ac:structured-macro>).*?' + 
        r'<ac:parameter ac:name="diagramName">(.*?)</ac:parameter>' + 
        r'.*?</ac:structured-macro>', 
        re.DOTALL | re.IGNORECASE
    )

    def replace_drawio(match):
        name = match.group(1).strip()
        return f"\n\n**[Draw.io Diagram: {name}]**\n\n"

    cleaned_html = pattern_drawio.sub(replace_drawio, html_content)

    # 2. PlantUML
    params_to_try = ['diagramName', 'title', 'filename', 'name']
    
    for param in params_to_try:
        pattern_plantuml = re.compile(
            r'<ac:structured-macro ac:name=".*?plantuml.*?"[^>]*>(?!.*<ac:structured-macro>).*?' + 
                f'<ac:parameter ac:name="{param}">(.*?)</ac:parameter>' + 
                r'.*?</ac:structured-macro>', 
            re.DOTALL | re.IGNORECASE
        )
        
        if pattern_plantuml.search(cleaned_html):
            cleaned_html = pattern_plantuml.sub(lambda m: f"\n\n**[PlantUML Diagram: {m.group(1).strip()}]**\n\n", cleaned_html)
            break 

    # 3. Fallback for PlantUML (No name found)
    pattern_plantuml_generic = re.compile(
        r'<ac:structured-macro ac:name=".*?plantuml.*?"[^>]*>(?!.*<ac:structured-macro>).*?</ac:structured-macro>', 
        re.DOTALL | re.IGNORECASE
    )
    
    if pattern_plantuml_generic.search(cleaned_html):
        print("      ⚠️  Using Fallback for unnamed PlantUML diagram.")
        cleaned_html = pattern_plantuml_generic.sub("\n\n**[PlantUML Diagram]**\n\n", cleaned_html)

    # 4. General Cleanup (ONLY for noise, Preserves Content)
    # Logic: Match a macro, UNLESS it contains structural HTML tags like <h1>, <p>, <div>
    # This ensures headers wrapped in panels/containers are NOT deleted.
    fallback_pattern = re.compile(
        r'<ac:structured-macro[^>]*>(?!.*<(?:h[1-6]|p|div)).*?</ac:structured-macro>', 
        re.DOTALL
    )
    
    # We only apply this if we want to remove generic noise macros.
    # If headers were skipped before, it was likely this regex removing their parent container.
    cleaned_html = fallback_pattern.sub("\n\n**[Confluence Macro]**\n\n", cleaned_html)

    return cleaned_html
