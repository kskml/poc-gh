import os
import re
from dotenv import load_dotenv
from openai import AzureOpenAI

# Load environment variables
load_dotenv()

def get_azure_client():
    """Initializes and returns the Azure OpenAI client."""
    return AzureOpenAI(
        api_key=os.getenv("AZURE_OPENAI_API_KEY"),
        api_version=os.getenv("AZURE_OPENAI_API_VERSION"),
        azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
    )

def extract_sections_from_page(page_content):
    """
    Parses a raw Confluence page string into a list of dictionaries.
    Each dictionary has a 'heading' and 'content'.
    """
    lines = page_content.split('\n')
    sections = []
    
    current_heading = "Overview" # Default for text before the first header
    current_content_lines = []
    
    # Regex to match Markdown headers (h1, h2, h3)
    header_pattern = re.compile(r'^(#{1,3})\s+(.*)$')

    for line in lines:
        match = header_pattern.match(line)
        if match:
            # Save the previous section if it exists
            full_content = "\n".join(current_content_lines).strip()
            if full_content:
                sections.append({
                    "heading": current_heading,
                    "content": full_content
                })
            
            # Start new section
            current_heading = match.group(2)
            current_content_lines = []
        else:
            current_content_lines.append(line)
    
    # Append the last section after the loop finishes
    full_content = "\n".join(current_content_lines).strip()
    if full_content:
        sections.append({
            "heading": current_heading,
            "content": full_content
        })
            
    return sections

def generate_instruction_for_section(heading, content, client, deployment_name):
    """
    Takes a specific section from the approved page and asks the LLM
    to generate a generalized 'Good Example' or 'Instruction' for it.
    """
    system_prompt = """
    You are an expert Technical Documentation Analyst.
    I will give you the 'Heading' and 'Content' from a perfect, approved Confluence page.
    
    Your task is to generate a "Golden Standard" instruction for this section.
    1. Remove specific names, dates, IDs, and technical jargon specific to this one instance.
    2. Replace them with generic placeholders (e.g., [Service Name], [Date], [Owner]).
    3. Preserve the structure, formatting, and logic.
    4. The result should look like a template or a set of instructions that another user could follow to fill out this section correctly on a new page.
    """

    user_prompt = f"""
    Heading: {heading}
    
    Actual Content from Approved Page:
    {content}
    
    Generate the generalized Good Example/Instruction.
    """

    try:
        response = client.chat.completions.create(
            model=deployment_name,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.3,
            max_tokens=1000
        )
        return response.choices[0].message.content
    except Exception as e:
        return f"Error generating instruction for {heading}: {str(e)}"

def process_approved_page(page_text):
    """
    Main function to process the approved page and print the results.
    """
    client = get_azure_client()
    deployment_name = os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME")
    
    # 1. Extract raw sections
    sections = extract_sections_from_page(page_text)
    
    print(f"Found {len(sections)} sections. Generating standards...\n")

    # 2. Generate instructions for each
    generated_standards = []
    
    for section in sections:
        heading = section['heading']
        content = section['content']
        
        # Skip very short snippets to save tokens
        if len(content) < 50:
            continue

        print(f"Processing section: {heading}...")
        
        standard_example = generate_instruction_for_section(
            heading, content, client, deployment_name
        )
        
        generated_standards.append({
            "heading": heading,
            "instruction": standard_example
        })
        
    return generated_standards

# --- Mock Data: Valid, Approved Confluence Page ---
# This is the "Gold Standard" page you want to learn from.
approved_page = """
# User Authentication Service

## Service Purpose
The User Auth Service is responsible for managing user logins, password resets, and JWT token generation. It ensures that only authorized personnel can access the HR Portal and the Payroll System.

## API Specification
This service exposes RESTful endpoints for external consumption.
*   `POST /api/v1/login` - Authenticates user credentials.
*   `POST /api/v1/logout` - Invalidates the current session.
*   `GET /api/v1/user/profile` - Returns user details based on the JWT token.

## Configuration Parameters
The service requires the following environment variables to start:
*   `DB_CONNECTION_STRING`: PostgreSQL connection string.
*   `JWT_SECRET_KEY`: The secret key used to sign tokens.
*   `LOG_LEVEL`: Set to 'INFO' for production, 'DEBUG' for dev.

## Support Contacts
For issues related to authentication failures, contact the Identity Team.
*   Team Lead: Alice (alice@company.com)
*   On-Call: Bob (bob@company.com)
"""

# --- Execution ---
if __name__ == "__main__":
    # Run the main processing function
    standards = process_approved_page(approved_page)
    
    # Print the final instructions
    print("\n" + "="*70)
    print("GENERATED VERIFICATION STANDARDS")
    print("="*70 + "\n")
    
    for item in standards:
        print(f"SECTION: {item['heading']}")
        print("-" * 70)
        print(item['instruction'])
        print("\n")
