import os
import re
from dotenv import load_dotenv
from openai import AzureOpenAI

# Load environment variables
load_dotenv()

class PageStandardExtractor:
    def __init__(self):
        self.client = AzureOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version=os.getenv("AZURE_OPENAI_API_VERSION"),
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
        )
        self.deployment_name = os.getenv("AZURE_OPENAI_DEPLOYMENT_NAME")

    def parse_page_content(self, page_content):
        """
        Parses a raw Confluence page (Markdown format) into a dictionary
        of { 'Heading': 'Content' }.
        """
        # Split by lines
        lines = page_content.split('\n')
        
        sections = {}
        current_heading = "Overview"  # Default section if text starts before a header
        current_content = []

        # Regex for Markdown headings (h1, h2, h3)
        header_pattern = re.compile(r'^(#{1,3})\s+(.*)$')

        for line in lines:
            match = header_pattern.match(line)
            if match:
                # Save the previous section
                if current_heading:
                    # Join content and strip extra whitespace
                    content_block = "\n".join(current_content).strip()
                    if content_block: # Only save if there is content
                        sections[current_heading] = content_block
                
                # Start a new section
                current_heading = match.group(2)
                current_content = []
            else:
                current_content.append(line)

        # Don't forget the last section
        if current_heading:
            sections[current_heading] = "\n".join(current_content).strip()

        return sections

    def generate_section_instruction(self, heading, actual_content):
        """
        Takes the actual content from the approved page and asks the LLM
        to abstract it into a generic instruction/example.
        """
        system_prompt = """
        You are an expert Technical Documentation Analyst. 
        I will provide you with a 'Heading' and the 'Actual Content' from a perfect, approved Confluence page.
        
        Your task is to analyze the content and generate a "Standard Instruction" or "Good Example" for that section.
        
        Rules:
        1. Remove specific details (e.g., change "Server X-99" to "Server Name", change specific dates to "Date").
        2. Preserve the structure, formatting (bullet points, tables), and tone.
        3. Identify the core objective of this section.
        4. The output should serve as a template or guide for someone writing a different page of the same type.
        """

        user_prompt = f"""
        Section Heading: {heading}
        
        Actual Approved Content:
        {actual_content}
        
        Please generate the generalized Good Example/Instruction for this section.
        """

        try:
            response = self.client.chat.completions.create(
                model=self.deployment_name,
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": user_prompt}
                ],
                temperature=0.3, # Low temperature for consistency and structure
                max_tokens=1000
            )
            return response.choices[0].message.content
        except Exception as e:
            return f"Error processing {heading}: {str(e)}"

    def process_approved_page(self, raw_page_text):
        sections = self.parse_page_content(raw_page_text)
        verification_guidelines = {}

        print(f"Analyzing {len(sections)} sections from the approved page...")

        for heading, content in sections.items():
            print(f"Extracting standard for: {heading}...")
            
            # Skip very short sections (less than 20 chars) to save tokens
            if len(content) < 20:
                continue
                
            instruction = self.generate_section_instruction(heading, content)
            verification_guidelines[heading] = instruction

        return verification_guidelines

# --- Mock Data: A Valid, Approved Confluence Page ---
# This represents the specific page you want to learn from.
approved_page_content = """
# Payment Gateway Service Documentation

## Service Overview
The Payment Gateway Service is a microservice responsible for handling all credit card transactions. It interfaces with Stripe and PayPal APIs to ensure secure processing. The service is built on Java Spring Boot and runs on Kubernetes cluster A.

## API Endpoints
The service exposes the following REST endpoints for transaction processing:

*   `POST /v1/charge` - Initiates a credit card charge.
*   `GET /v1/transaction/{id}` - Retrieves the status of a specific transaction.
*   `POST /v1/refund` - Processes a refund for a given transaction ID.

## Infrastructure Details
*   **Cluster:** Kubernetes Cluster A (us-east-1)
*   **Node Count:** 3 nodes (t3.medium)
*   **Database:** PostgreSQL 14, read-replicas enabled.
*   **Logging:** Logs are shipped to ELK Stack via Fluentd.

## On-Call Rotation
The team managing this service follows a standard 1-week rotation. 
Current Primary: John Doe (j.doe@company.com)
Current Shadow: Jane Smith (j.smith@company.com)
Escalation Manager: Mike Boss (m.boss@company.com)
"""

# --- Execution ---
if __name__ == "__main__":
    extractor = PageStandardExtractor()
    
    # 1. Process the approved page to get the "Golden Standards"
    standards = extractor.process_approved_page(approved_page_content)
    
    # 2. Display the results (This is what you use to verify other pages)
    print("\n" + "="*60)
    print("GENERATED INSTRUCTIONS & TEMPLATES")
    print("="*60 + "\n")
    
    for section, guide in standards.items():
        print(f"--- HEADING: {section} ---")
        print(guide)
        print("-" * 60 + "\n")
