Workflow Triggers
The automated architecture documentation workflow can be initiated by several different events. The choice of trigger depends on the team's development process, the desired level of control, and the integration maturity between GitHub and Jira.

Below are the three primary trigger mechanisms we can implement.

1. Trigger on GitHub Push Event
This is the most straightforward and common CI/CD trigger. The workflow is configured to run automatically on every push to a specific branch, such as main or develop.

{info:title=How it Works}
The CI/CD platform (e.g., GitHub Actions, GitLab CI) is configured with a trigger that listens for a push event on the target branch. Once the push is detected, the workflow begins its process of fetching the diff, analyzing it, and creating a Jira ticket if necessary.
{info}

Pros
Simplicity: Easy to configure and understand. It's a standard feature of all modern CI/CD systems.
Guaranteed Execution: Every merge to the branch is checked, ensuring no architectural change is missed.
Fast Feedback: The analysis runs immediately after the code is merged, providing the quickest possible feedback.
Cons
Resource Intensive: The workflow will run on every merge, even for minor changes (e.g., typo fixes, dependency updates) that do not affect the architecture. This can consume CI/CD minutes and API calls unnecessarily.
Lacks Business Context: The workflow is unaware of the state of the corresponding Jira ticket. It might create a documentation task for a feature that has been deprioritized or cancelled in Jira.
2. Trigger on GitHub Push Event with Jira Ticket Status Check
This is a more advanced, conditional trigger. The workflow still initiates on a GitHub push, but it performs an initial check to verify the status of the associated Jira ticket before proceeding with the full analysis.

{info:title=How it Works}

The CI/CD workflow is triggered by a push event to the target branch.
The script first extracts the Jira ticket ID from the latest commit message or PR title.
It makes an API call to Jira to fetch the status of that ticket (e.g., "In Progress", "Done", "Blocked").
The workflow only proceeds with the Confluence/AI analysis if the ticket status matches a predefined list of acceptable states (e.g., "Done" or "Ready for QA").
{info}
Pros
Resource Efficient: Prevents the workflow from running on trivial or irrelevant changes, saving CI/CD resources and API quota.
Business Alignment: Ensures documentation is only requested for work that has reached a significant milestone, aligning the technical process with the project management process.
Reduced Noise: Fewer unnecessary Jira tickets are created, reducing noise for the architecture team.
Cons
Increased Complexity: The CI/CD script becomes more complex, as it needs to handle API calls to Jira, error handling for missing tickets, and conditional logic.
Dependency on Jira: The workflow's execution is now dependent on the availability and responsiveness of the Jira API. A Jira outage could delay or break the process.
Assumes Good Hygiene: Relies on developers consistently including the correct Jira ticket ID in their commit messages or PR titles.
3. Trigger Only on Jira Ticket Status Transition
This is the most sophisticated trigger, moving the initiation point entirely from GitHub to Jira. The workflow is decoupled from the code push event and is instead triggered by a change in Jira.

{info:title=How it Works}

A Jira Webhook is configured to fire when a ticket transitions to a specific status (e.g., from "In Progress" to "Done").
This webhook sends a payload to an intermediary service, such as an AWS Lambda function, a serverless Azure Function, or a Jenkins job.
This service receives the Jira ticket ID from the webhook payload.
It then uses the Jira API to find the associated GitHub repository and Pull Request(s).
Finally, it programmatically triggers the documentation analysis workflow, passing the necessary context (repo, PR, etc.) to it.
{info}
Pros
Ultimate Business Alignment: The documentation process is triggered directly by a business decision (the completion of a task), making it the most context-aware approach.
Decoupled: The architecture analysis is completely separate from the CI/CD pipeline, which can simplify the main build and deployment process.
Highly Efficient: The analysis runs only when explicitly needed, eliminating all wasted executions.
Cons
Highest Complexity: This is the most difficult to set up and maintain. It requires building and maintaining a separate intermediary service to handle webhooks and trigger the workflow.
More Points of Failure: The chain involves Jira, the Jira Webhook system, the intermediary service, and the final workflow, increasing the number of potential failure points.
Requires Advanced Integration: Needs robust integration between Jira and GitHub to reliably find the correct PR for a given Jira ticket, which can be challenging if the link is not consistently maintained.

4.Trigger on Manual GitHub Release
This approach decouples the workflow from individual code pushes and instead ties it to a significant milestone: the creation of a new release. This provides developers with full control over when the architecture documentation is reviewed.

{info:title=How it Works}

A developer creates a new Git tag (e.g., v1.2.0) and pushes it to GitHub, creating a new Release from the GitHub UI or via the command line.
The CI/CD workflow is configured with a trigger that listens specifically for the creation of a new release event.
When triggered, the script first identifies the new tag (e.g., v1.2.0) and then programmatically finds the previous tag (e.g., v1.1.0).
It then generates a code diff encompassing all changes between these two tags (git diff v1.1.0...v1.2.0).
The rest of the workflow proceeds as usual: it fetches relevant Confluence pages, analyzes the comprehensive diff with the AI, and creates a single Jira ticket summarizing all documentation gaps for the entire release.
{info}
Pros
Full Developer Control: The team decides exactly when to run the documentation review, aligning it with their release cadence.
Highly Resource Efficient: The workflow runs only once per release cycle, dramatically reducing CI/CD minutes, API calls, and noise compared to running on every merge.
Release-Centric Review: Provides a holistic, high-level review of all architectural changes introduced in a release, which is ideal for updating major documentation versions.
Reduced Noise: Creates a single, comprehensive Jira ticket per release, consolidating all documentation tasks into one manageable unit.
Cons
Significant Documentation Lag: Gaps are not identified until a release is tagged, which could be weeks or months after the code was merged. This allows architectural drift to go unchecked for long periods.
Relies on Manual Discipline: The entire process depends on a developer remembering to create the release tag. If this step is missed, the workflow is bypassed entirely.
Large Diff Complexity: The diff between two releases can be substantial. A very large diff may be difficult for the AI model to process accurately, potentially leading to less precise analysis or missing subtle but important changes.
Delayed Feedback: Architectural issues are not caught early in the development cycle. By the time the ticket is created, the problematic code may already be in production, making it harder and more costly to fix.
