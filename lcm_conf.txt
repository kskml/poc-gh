def analyze_single_section(client, deployment_name, section_header, section_content, full_diff, local_diag_path, exclude_list):
    """
    Invokes LLM with Text AND Diagram context.
    STRATEGY SWITCH: LLM generates Data (CSV), Python generates HTML Table.
    """
    
    # 1. Check Exclusions
    for exclude_term in exclude_list:
        if exclude_term.lower() in section_header.lower():
            print(f"      ‚è≠Ô∏è  Section excluded (Matches '{exclude_term}').")
            return "NO_IMPACT"
    
    # 2. Regex for Diagrams
    pattern = re.compile(r'<<<\s*(PLANTUML|DRAWIO|DRAW)\s*DIAGRAM(.*?)\s*>>>', re.IGNORECASE)
    matches = pattern.findall(section_content)
    
    if len(matches) == 0:
        if "DIAGRAM" in section_content:
            snippet = section_content[:500]
            print(f"      ‚ö†Ô∏è  Word 'DIAGRAM' found but regex didn't match. Snippet: {snippet}...")
        else:
            print(f"      ‚ÑπÔ∏è  No diagrams detected in this section.")

    diagram_contexts = []
    
    for match in matches:
        diag_type, diag_name = match
        diag_name = diag_name.strip(" :")
        if not diag_name:
            diag_name = "Unknown"
        
        if "plantuml" in diag_type.lower():
            diag_content = find_local_diagram(diag_name, local_diag_path)
            if diag_content:
                diagram_contexts.append(f"\n--- DIAGRAM CONTEXT: {diag_name} ---\n{diag_content}\n")
    
    prompt_diagrams = "\n".join(diagram_contexts) if diagram_contexts else "No local diagrams found for this section."
    
    system_prompt = """
    You are an ASPICE SWE.2 Auditor analyzing a Documentation Section against Code Changes.
    
    **Context:**
    1. Confluence Text Content.
    2. (Optional) Local PlantUML Diagrams.
    
    **Instructions:**
    1. Check if Code Diff affects Text OR Diagram Logic.
    2. Return `NO_IMPACT` if aligned.
    3. If gap found, return ONLY a **Pipe-Separated Data Line**.
    
    **OUTPUT FORMAT (Crucial):**
    - Do NOT output HTML tags (<table>, <tr>, etc.).
    - Return a single line of data separated by `||`.
    - Format: Severity || Section || Scope || Observation || Action || Diagram
    - **Diagram Column:** If updating a diagram, include the FULL CODE BLOCK in this column. Use `<br/>` for line breaks in code.
    
    **Strict Order:**
    1 | üî¥ **NON-CONFORMANT** | <SECTION_TITLE> | UI/Logic/Data/API | [Observation] | [Text Only] |
    1 | üî¥ **NON-CONFORMANT** | <SECTION_TITLE> | UI/Logic/Data/API | [Observation] | [Text Only] || <br/>```plantuml<br/>code<br/>```
    """

    user_prompt = f"""
    <SECTION_TITLE>{section_header}</SECTION_TITLE>
    
    CONFLUENCE TEXT CONTENT:
    {section_content}

    --- 
    
    LOCAL DIAGRAMS (PlantUML Logic):
    {prompt_diagrams}

    ---
    
    GITHUB CODE DIFF:
    {full_diff}
    """
    
    try:
        response = client.chat.completions.create(
            model=deployment_name,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"Error analyzing section '{section_header}': {e}")
        return "NO_IMPACT"

def generate_html_report(rows, base_tag, head_tag):
    """
    Constructs a robust HTML table from the data rows.
    This ensures valid HTML structure every time.
    """
    html_parts = []
    
    # 1. Start Table
    html_parts.append("<table class='wrapped'><tbody>")
    
    for row_string in rows:
        # Split by double pipe
        cells = row_string.split("||")
        
        # Ensure we have enough cells (pad with empty if necessary)
        # Expected: ID, Severity, Section, Scope, Observation, Action, Diagram
        while len(cells) < 6:
            cells.append("")
        
        row_html = "<tr>"
        
        # Process each cell
        for cell_content in cells:
            # Escape HTML entities in the text
            safe_content = cell_content.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
            
            # Detect if this cell is the Diagram column (index 5)
            # and contains code block syntax
            if "```plantuml" in safe_content:
                # Convert markdown code block to HTML pre/code block
                # Remove backticks
                code_body = safe_content.replace("```plantuml", "").replace("```", "")
                # Replace newlines with <br/>
                clean_code = code_body.replace("\n", "<br/>")
                cell_data = f"<pre><code class='language-plantuml'>{clean_code}</code></pre>"
            else:
                # Standard text cell - replace newlines with break
                cell_data = safe_content.replace("\n", "<br/>")
            
            row_html += f"<td>{cell_data}</td>"
        
        row_html += "</tr>"
        html_parts.append(row_html)
        
    # 2. End Table
    html_parts.append("</tbody></table>")
    return "".join(html_parts)

def main():
    # --- ARGUMENT PARSING ---
    parser = argparse.ArgumentParser(description="ASPICE SWE.2 Confluence vs Code Analyzer")
    
    parser.add_argument("--base-tag", required=True, help="Base Git Tag (e.g., v1.0.0)")
    parser.add_argument("--head-tag", required=True, help="Head Git Tag (e.g., v1.1.0)")
    parser.add_argument("--page-id", required=True, help="Confluence Page ID")
    parser.add_argument("--module-path", required=True, help="Local Path to Diagrams (Module Path)")
    parser.add_argument("--split-level", type=int, default=3, help="Header Level to split on (e.g., 3 for ###)")
    parser.add_argument("--exclude-sections", default="", help="Comma separated keywords to skip (e.g., 'Use Case, Example')")
    
    parser.add_argument("--repo-owner", default=os.getenv("GITHUB_REPO_OWNER"), help="GitHub Repo Owner")
    parser.add_argument("--repo-name", default=os.getenv("GITHUB_REPO_NAME"), help="GitHub Repo Name")
    
    args = parser.parse_args()

    # Process Exclude List
    exclude_list = [x.strip().lower() for x in args.exclude_sections.split(",")] if args.exclude_sections else []

    # --- SETUP ---
    try:
        client = AzureOpenAI(
            api_key=os.getenv("AZURE_OPENAI_API_KEY"),
            api_version=os.getenv("AZURE_OPENAI_API_VERSION"),
            azure_endpoint=os.getenv("AZURE_OPENAI_ENDPOINT")
        )
    except Exception as e:
        print(f"‚ùå Initialization Error: {e}")
        return

    confl_base = os.getenv("CONFLUENCE_BASE_URL")
    confl_email = os.getenv("CONFLUENCE_EMAIL")
    confl_token = os.getenv("CONFLUENCE_API_TOKEN")
    github_token = os.getenv("GITHUB_TOKEN")
    deployment_name = os.getenv("AZURE_OPENAI_DEPLOYMENT")

    if not all([confl_base, confl_email, confl_token, github_token, deployment_name]):
        print("‚ùå Error: Missing Secrets in Environment Variables.")
        return

    try:
        # Use Args for inputs
        doc_text = get_confluence_content(confl_base, confl_email, confl_token, args.page_id)
        sections = chunk_confluence_hierarchical(doc_text, args.split_level)
        
        full_diff = get_full_github_diff(
            args.repo_owner, args.repo_name, 
            args.base_tag, args.head_tag, 
            github_token
        )
        
        if not full_diff:
            print("‚ö†Ô∏è  No Diff found.")
            return

        print(f"üîÑ Starting Analysis across {len(sections)} sections...")
        accumulated_rows = []
        
        for idx, section in enumerate(sections):
            print(f"   Analyzing Section {idx+1}/{len(sections)}: {section['header']}")
            
            result = analyze_single_section(
                client, 
                deployment_name, 
                section['header'], 
                section['content'], 
                full_diff,
                args.module_path,
                exclude_list
            )
            
            # ROBUST FILTER LOGIC
            if result and result != "NO_IMPACT":
                # Check for table rows (starts with ID, Severity etc.)
                # Pipe-separated rows will typically start with "1 |" or "1 ||"
                if result.startswith("1") or result.startswith("1 ||"):
                    accumulated_rows.append(result)
                    print(f"      ‚Üí Impact Found.")
                else:
                    print(f"      ‚ö†Ô∏è  Skipping (Not a data row).")
            else:
                print(f"      ‚Üí No Impact. Skipping.")

        # Generate Report
        if not accumulated_rows:
            print("‚úÖ No gaps found.")
        else:
            with open("Arg_Analyzer_Report.md", "w", encoding="utf-8") as f:
                f.write("# ASPICE SWE.2 Analysis\n\n")
                f.write(f"**Release:** `{args.base_tag}` ‚Üí `{args.head_tag}`\n\n")
                f.write("## Assessment Criteria\n\n")
                f.write("| Option | Definition |\n| :--- | :--- |\n")
                f.write("| üî¥ **NON-CONFORMANT** | Code contradicts doc or diagram. |\n")
                f.write("| üü† **GAP IDENTIFIED** | Code adds missing feature. |\n")
                f.write("| üî¥ **NON-CONFORMANT / GAP** | Complex change. |\n")
                f.write("| üü° **INCONSISTENCY** | Minor mismatch. |\n\n")
                f.write("## Analysis\n\n")
                
                # Call HTML generation function
                table_html = generate_html_report(accumulated_rows, args.base_tag, args.head_tag)
                f.write(table_html)
                
            print(f"‚úÖ Report generated (Python-Generated HTML Table).")

    except Exception as e:
        print(f"‚ùå Error: {e}")

if __name__ == "__main__":
    main()
