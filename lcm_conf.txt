# ... (previous imports) ...
from bs4 import BeautifulSoup

def clean_confluence_html(html_content):
    """
    Uses BeautifulSoup to safely remove macros.
    FIX: Forces consistent '<<< TYPE DIAGRAM: Name >>>' format for ALL diagrams.
    This ensures Regex in analyze_single_section can match them.
    """
    print("   Cleaning macros with BeautifulSoup (Consistent Format)...")
    
    soup = BeautifulSoup(html_content, 'html.parser')
    
    # Find all structured macros
    macros = soup.find_all('ac:structured-macro')
    
    if not macros:
        print("      No macros found in HTML.")
        return str(soup)
        
    print(f"      Found {len(macros)} macros to process.")
    
    for macro in macros:
        macro_name = macro.get('ac:name', '').lower()
        
        # Check if it is a diagram macro
        if 'plantuml' in macro_name or 'drawio' in macro_name or 'draw.io' in macro_name:
            diag_name = "Unknown"
            
            # Try to find name in parameters
            params = macro.find_all('ac:parameter')
            for param in params:
                param_name = param.get('ac:name', '').lower()
                if param_name in ['diagramname', 'title', 'filename', 'name']:
                    diag_name = param.get_text(strip=True)
                    break
            
            # --- FIX: Use consistent ASCII format for BOTH ---
            # Format: <<< TYPE DIAGRAM: Name >>>
            # This matches the Regex in analyze_single_section
            
            if 'plantuml' in macro_name:
                placeholder = f"\n\n<<< PLANTUML DIAGRAM: {diag_name} >>>\n\n"
            else: # Draw.io
                placeholder = f"\n\n<<< DRAWIO DIAGRAM: {diag_name} >>>\n\n"
            
            # Replace the macro tag with the placeholder
            macro.replace_with(placeholder)
    
    return str(soup)

# ... (other functions: get_confluence_content, find_local_diagram, etc.) ...

def analyze_single_section(client, deployment_name, section_header, section_content, full_diff, local_diag_path):
    """
    Invokes LLM with Text AND Diagram context.
    FIX: Refined Regex to strictly match <<< TYPE DIAGRAM: Name >>> format.
    """
    
    # REFINED REGEX
    # Matches: <<< PLANTUML DIAGRAM: Name >>> or <<< DRAWIO DIAGRAM: Name >>>
    # \s* allows whitespace. \s*:\s* handles the colon clearly.
    pattern = re.compile(r'<<<\s*(PLANTUML|DRAWIO)\s*DIAGRAM\s*:\s*(.*?)\s*>>>', re.IGNORECASE)
    
    matches = pattern.findall(section_content)
    
    if len(matches) == 0:
        if "DIAGRAM" in section_content:
            print(f"      ‚ö†Ô∏è  Word 'DIAGRAM' found but regex didn't match.")
            # Print snippet to debug
            idx = section_content.find("DIAGRAM")
            snippet = section_content[max(0, idx-50):min(len(section_content), idx+50)]
            clean_snippet = snippet.replace("\n", "\\n")
            print(f"      Snippet: ...{clean_snippet}...")
        else:
            print(f"      ‚ÑπÔ∏è  No diagrams detected in this section.")

    diagram_contexts = []
    
    for match in matches:
        # Group 1: Type, Group 2: Name
        diag_type, diag_name = match
        diag_name = diag_name.strip(" :")
        if not diag_name:
            diag_name = "Unknown"
        
        if "plantuml" in diag_type.lower():
            diag_content = find_local_diagram(diag_name, local_diag_path)
            if diag_content:
                diagram_contexts.append(f"\n--- DIAGRAM CONTEXT: {diag_name} ---\n{diag_content}\n")
    
    prompt_diagrams = "\n".join(diagram_contexts) if diagram_contexts else "No local diagrams found for this section."
    
    system_prompt = """
    You are an ASPICE SWE.2 Auditor analyzing a Documentation Section against Code Changes.
    
    **Context:**
    1. Confluence Text Content.
    2. (Optional) Local PlantUML Diagrams.
    
    **Instructions:**
    1. Check if Code Diff affects Text OR Diagram Logic.
    2. Return `NO_IMPACT` if aligned.
    3. If gap found, return ONLY a Markdown table row.
    
    **Row Format:**
    | ID | Severity | Confluence Section | Impact Scope | SWE.2 Observation (Functional) | Corrective Action |
    | 1 | üî¥ **NON-CONFORMANT** | <SECTION_TITLE> | UI/Logic/Data/API | [Observation] | [Action] |
    """

    user_prompt = f"""
    <SECTION_TITLE>{section_header}</SECTION_TITLE>
    
    CONFLUENCE TEXT CONTENT:
    {section_content}

    --- 
    
    LOCAL DIAGRAMS (PlantUML Logic):
    {prompt_diagrams}

    ---
    
    GITHUB CODE DIFF:
    {full_diff}
    """
    
    try:
        response = client.chat.completions.create(
            model=deployment_name,
            messages=[
                {"role": "system", "content": system_prompt},
                {"role": "user", "content": user_prompt}
            ],
            temperature=0.1
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        print(f"Error analyzing section '{section_header}': {e}")
        return "NO_IMPACT"

# ... (rest of script: chunk_confluence_hierarchical, main, etc.) ...
